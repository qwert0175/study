# Array(배열)

<br>

### 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 알고리즘

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목별 발생 횟수를 기록하기 위해 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.

- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.

- 시간 복잡도 : O(n + k) : n은 리스트 길이 k는 정수의 최대값

<br>

### 카운팅 정렬 과정

- data : 원본 배열, counts : 개수 배열, temp : 정렬 배열

1. data 각 항목들의 발생 횟수를 세고 정수 항목들로 직접 인덱스되는 카운트 배열 counts에 저장한다.

2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.

3. data의 마지막 원소부터 count를 감소시키면서 temp에 넣음

<br>

### 정렬 알고리즘 비교

|알고리즘|평균 수행시간|최악 수행시간|알고리즘 기법|비고|
|버블 정렬|O(n**2)|O(n**2)|비교와 교환|코딩이 가장 손쉽다.|
|카운팅 정렬|O(n+k)|O(n+k)|비교환 방식|k가 비교적 작을 때만 가능하다.|
|선택 정렬|O(n**2)|O(n**2)|비교와 교환|교환의 회수가 버블, 삽입정렬보다 작다.|
|퀵 정렬|O(n log n)|O(n**2)|분할 정복|최악의 경우 O(n**2)이지만 평균적으로 가장 빠르다.|
|삽입 정렬|O(n**2)|O(n**2)|비교와 교환|n의 개수가 작을 때 효과적이다.|
|병합 정렬|O(n log n)|O(n log n)|분할 정복|연결리스트의 경우 가장 효율적인 방식|

### 완전 검색

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

- brute-force 혹은 generate-and-test 기법

- 모든 경우의 수를 테스트 한 후 최종 해법을 도출

- 일반적으로 경우의 수가 상대적으로 작을 때 유용

- 수행 속도가 느리지만 해답을 찾아내지 못할 확률이 낮음

### 순열

- 서로 다른 것들 중 몇개를 뽑아서 한줄로 나열하는 것

- 서로 다른 n개 중 r개를 택하는 순열 : nPr

### 그리디 알고리즘

- 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식

- 각 선택은 지역적으로는 최적이지만, 최종적으로 최적이라는 보장은 없음

- 